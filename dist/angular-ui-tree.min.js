/**
 * @license Angular UI Tree v2.0.0
 * (c) 2010-2014. https://github.com/JimLiu/angular-ui-tree
 * License: MIT
 */
!function(){"use strict";angular.module("ui.tree",[]).constant("treeConfig",{treeClass:"angular-ui-tree",hiddenClass:"angular-ui-tree-hidden",nodesClass:"angular-ui-tree-nodes",nodeClass:"angular-ui-tree-node",handleClass:"angular-ui-tree-handle",placeHolderClass:"angular-ui-tree-placeholder",dragClass:"angular-ui-tree-drag",dragThreshold:3,levelThreshold:30})}(),function(){"use strict";angular.module("ui.tree").factory("$helper",["$document","$window",function($document,$window){return{nodrag:function(targetElm){return"undefined"!=typeof targetElm.attr("data-nodrag")},eventObj:function(e){var obj=e;return void 0!==e.targetTouches?obj=e.targetTouches.item(0):void 0!==e.originalEvent&&void 0!==e.originalEvent.targetTouches&&(obj=e.originalEvent.targetTouches.item(0)),obj},dragInfo:function(node){return{source:node,index:node.$index,siblings:node.$parentNodesScope.$nodes.slice(0),parent:node.$parentNodesScope,moveTo:function(parent,siblings,index){this.parent=parent,this.siblings=siblings.slice(0);var i=this.siblings.indexOf(this.source);i>-1&&(this.siblings.splice(i,1),this.source.$index<index&&index--),this.siblings.splice(index,0,this.source),this.index=index},parentNode:function(){return this.parent.$nodeScope},prev:function(){return this.index>0?this.siblings[this.index-1]:null},next:function(){return this.index<this.siblings.length-1?this.siblings[this.index+1]:null},isDirty:function(){return this.source.$parentNodesScope!=this.parent||this.source.$index!=this.index},apply:function(){this.source.remove(),this.parent.insertNode(this.index,this.source)}}},height:function(element){return element.prop("scrollHeight")},width:function(element){return element.prop("scrollWidth")},offset:function(element){var boundingClientRect=element[0].getBoundingClientRect();return{width:element.prop("offsetWidth"),height:element.prop("offsetHeight"),top:boundingClientRect.top+($window.pageYOffset||$document[0].body.scrollTop||$document[0].documentElement.scrollTop),left:boundingClientRect.left+($window.pageXOffset||$document[0].body.scrollLeft||$document[0].documentElement.scrollLeft)}},positionStarted:function(e,target){var pos={};return pos.offsetX=e.pageX-this.offset(target).left,pos.offsetY=e.pageY-this.offset(target).top,pos.startX=pos.lastX=e.pageX,pos.startY=pos.lastY=e.pageY,pos.nowX=pos.nowY=pos.distX=pos.distY=pos.dirAx=0,pos.dirX=pos.dirY=pos.lastDirX=pos.lastDirY=pos.distAxX=pos.distAxY=0,pos},positionMoved:function(e,pos,firstMoving){pos.lastX=pos.nowX,pos.lastY=pos.nowY,pos.nowX=e.pageX,pos.nowY=e.pageY,pos.distX=pos.nowX-pos.lastX,pos.distY=pos.nowY-pos.lastY,pos.lastDirX=pos.dirX,pos.lastDirY=pos.dirY,pos.dirX=0===pos.distX?0:pos.distX>0?1:-1,pos.dirY=0===pos.distY?0:pos.distY>0?1:-1;var newAx=Math.abs(pos.distX)>Math.abs(pos.distY)?1:0;return firstMoving?(pos.dirAx=newAx,void(pos.moving=!0)):(pos.dirAx!==newAx?(pos.distAxX=0,pos.distAxY=0):(pos.distAxX+=Math.abs(pos.distX),0!==pos.dirX&&pos.dirX!==pos.lastDirX&&(pos.distAxX=0),pos.distAxY+=Math.abs(pos.distY),0!==pos.dirY&&pos.dirY!==pos.lastDirY&&(pos.distAxY=0)),void(pos.dirAx=newAx))}}}])}(),function(){"use strict";angular.module("ui.tree").controller("TreeNodesController",["$scope","$element","treeConfig",function($scope,$element){this.scope=$scope,$scope.$element=$element,$scope.$modelValue=null,$scope.$nodes=[],$scope.$nodeScope=null,$scope.$callbacks=null,$scope.$type="uiTreeNodes",$scope.initSubNode=function(subNode){$scope.$nodes.splice(subNode.$index,0,subNode)},$scope.accept=function(sourceNode,destIndex){return $scope.$callbacks.accept(sourceNode,$scope,destIndex)},$scope.apply=function(){"$apply"!=$scope.$root.$$phase&&"$digest"!=$scope.$root.$$phase&&$scope.$apply()},$scope.removeNode=function(node){var index=$scope.$nodes.indexOf(node);return index>-1?($scope.$modelValue.splice(index,1)[0],$scope.$nodes.splice(index,1)[0],$scope.apply(),node):null},$scope.insertNode=function(index,node){$scope.$modelValue.splice(index,0,node.$modelValue),$scope.apply()};var collapseOrExpand=function(scope,collapsed){for(var i=0;i<scope.nodes.length;i++){collapsed?scope.nodes[i].collapse():scope.nodes[i].expand();var subScope=scope.nodes[i].$childNodesScope;subScope&&collapseOrExpand(subScope,collapsed)}};$scope.collapseAll=function(){collapseOrExpand($scope,!0)},$scope.expandAll=function(){collapseOrExpand($scope,!1)}}])}(),function(){"use strict";angular.module("ui.tree").controller("TreeNodeController",["$scope","$element","$attrs","treeConfig",function($scope,$element){this.scope=$scope,$scope.$element=$element,$scope.$modelValue=null,$scope.$parentNodeScope=null,$scope.$childNodesScope=null,$scope.$parentNodesScope=null,$scope.$type="uiTreeNode",$scope.collapsed=!1,$scope.isSibling=function(targetNode){return $scope.$parentNodeScope==targetNode.$parentNodeScope},$scope.isChild=function(node){var nodes=$scope.childNodes();return nodes.indexOf(node)>-1},$scope.prev=function(){return $scope.$index>0?$scope.siblings()[$scope.$index-1]:null},$scope.siblings=function(){return $scope.$parentNodesScope.$nodes},$scope.childNodesCount=function(){return $scope.childNodes().length},$scope.childNodes=function(){return $scope.$childNodesScope.$nodes},$scope.accept=function(sourceNode,destIndex){return $scope.$childNodesScope.accept(sourceNode,destIndex)},$scope.remove=function(){return $scope.$parentNodesScope.removeNode($scope)},$scope.insertNode=function(index,node){$scope.$childNodesScope.insertNode(index,node)},$scope.toggle=function(){$scope.collapsed=!$scope.collapsed},$scope.collapse=function(){$scope.collapsed=!0},$scope.expand=function(){$scope.collapsed=!1}}])}(),function(){"use strict";angular.module("ui.tree").directive("uiTreeNodes",["treeConfig","$window",function(treeConfig){return{require:["ngModel","?^uiTreeNode"],restrict:"A",scope:!0,controller:"TreeNodesController",link:function(scope,element,attrs,controllersArr){var callbacks={accept:null},config={};angular.extend(config,treeConfig),config.nodesClass&&element.addClass(config.nodesClass);var ngModel=controllersArr[0],treeNodeCtrl=controllersArr[1];treeNodeCtrl&&(treeNodeCtrl.scope.$childNodesScope=scope,scope.$nodeScope=treeNodeCtrl.scope),ngModel&&(ngModel.$render=function(){scope.$modelValue=ngModel.$modelValue}),callbacks.accept=function(sourceNode,destNodes){return"undefined"==typeof destNodes.$element.attr("data-nodrop")},scope.$watch(attrs.uiTreeNodes,function(newVal){angular.forEach(newVal,function(value,key){callbacks[key]&&"function"==typeof value&&(callbacks[key]=value)}),scope.$callbacks=callbacks},!0)}}}])}(),function(){"use strict";angular.module("ui.tree").directive("uiTreeNode",["treeConfig","$helper","$window","$document",function(treeConfig,$helper,$window,$document){return{require:"^uiTreeNodes",restrict:"A",controller:"TreeNodeController",link:function(scope,element,attrs,treeNodesCtrl){var config={};angular.extend(config,treeConfig),config.nodeClass&&element.addClass(config.nodeClass),scope.$parentNodeScope=treeNodesCtrl.scope.$nodeScope,scope.$modelValue=treeNodesCtrl.scope.$modelValue[scope.$index],scope.$parentNodesScope=treeNodesCtrl.scope,treeNodesCtrl.scope.initSubNode(scope),element.on("$destroy",function(){});var firstMoving,dragInfo,pos,placeElm,hiddenPlaceElm,dragElm,hasTouch="ontouchstart"in window,dragStartEvent=function(e){if((hasTouch||2!=e.button&&3!=e.which)&&!e.uiTreeDragging){for(var eventElm=angular.element(e.target);eventElm&&eventElm[0]&&eventElm[0]!=element;){if($helper.nodrag(eventElm))return;eventElm=eventElm.parent()}e.uiTreeDragging=scope,e.preventDefault();var eventObj=$helper.eventObj(e);firstMoving=!0,dragInfo=$helper.dragInfo(scope);var tagName=scope.$element.prop("tagName");if("tr"===tagName.toLowerCase()){placeElm=angular.element($window.document.createElement(tagName));var tdElm=angular.element($window.document.createElement("td")).addClass(config.placeHolderClass);placeElm.append(tdElm)}else placeElm=angular.element($window.document.createElement(tagName)).addClass(config.placeHolderClass);hiddenPlaceElm=angular.element($window.document.createElement(tagName)),config.hiddenClass&&hiddenPlaceElm.addClass(config.hiddenClass),pos=$helper.positionStarted(eventObj,scope.$element),placeElm.css("height",$helper.height(scope.$element)+"px"),dragElm=angular.element($window.document.createElement(scope.$parentNodesScope.$element.prop("tagName"))).addClass(scope.$parentNodesScope.$element.attr("class")).addClass(config.dragClass),dragElm.css("width",$helper.width(scope.$element)+"px"),dragElm.css("z-index",9999),scope.$element.after(placeElm),scope.$element.after(hiddenPlaceElm),dragElm.append(scope.$element),$document.find("body").append(dragElm),dragElm.css({left:eventObj.pageX-pos.offsetX+"px",top:eventObj.pageY-pos.offsetY+"px"}),hasTouch?(angular.element($document).bind("touchend",dragEndEvent),angular.element($document).bind("touchcancel",dragEndEvent),angular.element($document).bind("touchmove",dragMoveEvent)):(angular.element($document).bind("mouseup",dragEndEvent),angular.element($document).bind("mousemove",dragMoveEvent),angular.element($window.document.body).bind("mouseleave",dragEndEvent))}},dragMoveEvent=function(e){var prev,eventObj=$helper.eventObj(e);if(dragElm){if(e.preventDefault(),dragElm.css({left:eventObj.pageX-pos.offsetX+"px",top:eventObj.pageY-pos.offsetY+"px"}),$helper.positionMoved(e,pos,firstMoving),firstMoving)return void(firstMoving=!1);if(pos.dirAx&&pos.distAxX>=config.levelThreshold&&(pos.distAxX=0,pos.distX>0&&(prev=dragInfo.prev(),prev&&!prev.collapsed&&prev.accept(scope,prev.childNodesCount())&&(prev.$childNodesScope.$element.append(placeElm),dragInfo.moveTo(prev.$childNodesScope,prev.childNodes(),prev.childNodesCount()))),pos.distX<0)){var next=dragInfo.next();if(!next){var target=dragInfo.parentNode();target&&target.$parentNodesScope.accept(scope,target.$index+1)&&(target.$element.after(placeElm),dragInfo.moveTo(target.$parentNodesScope,target.siblings(),target.$index+1))}}var targetX=($helper.offset(dragElm).left-$helper.offset(placeElm).left>=config.threshold,eventObj.pageX-$window.document.body.scrollLeft),targetY=eventObj.pageY-(window.pageYOffset||$window.document.documentElement.scrollTop);angular.isFunction(dragElm.hide)&&dragElm.hide(),$window.document.elementFromPoint(targetX,targetY);var targetElm=angular.element($window.document.elementFromPoint(targetX,targetY));if(angular.isFunction(dragElm.show)&&dragElm.show(),!pos.dirAx){var targetBefore,targetNode;if(targetNode=targetElm.scope(),"uiTreeNode"!=targetNode.$type)return;targetElm=targetNode.$element;var targetOffset=$helper.offset(targetElm);targetBefore=eventObj.pageY<targetOffset.top+$helper.height(targetElm)/2,targetNode.$parentNodesScope.accept(scope,targetNode.$index)&&(targetBefore?(targetElm[0].parentNode.insertBefore(placeElm[0],targetElm[0]),dragInfo.moveTo(targetNode.$parentNodesScope,targetNode.siblings(),targetNode.$index)):(targetElm.after(placeElm),dragInfo.moveTo(targetNode.$parentNodesScope,targetNode.siblings(),targetNode.$index+1)))}}},dragEndEvent=function(e){e.preventDefault(),dragElm&&(scope.$element.remove(),hiddenPlaceElm.replaceWith(scope.$element),placeElm.remove(),dragElm.remove(),dragElm=null,console.log(dragInfo),dragInfo.apply(),dragInfo=null),hasTouch?(angular.element($document).unbind("touchend",dragEndEvent),angular.element($document).unbind("touchcancel",dragEndEvent),angular.element($document).unbind("touchmove",dragMoveEvent)):(angular.element($document).unbind("mouseup",dragEndEvent),angular.element($document).unbind("mousemove",dragMoveEvent),angular.element($window.document.body).unbind("mouseleave",dragEndEvent))};hasTouch?element.bind("touchstart",dragStartEvent):element.bind("mousedown",dragStartEvent)}}}])}();